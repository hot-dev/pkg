::xai::collections ns

// ============================================================================
// xAI Collections API
// https://docs.x.ai/docs/guides/using-collections/api
//
// Collections enables management of documents with automatic embeddings
// for semantic search. Files uploaded to collections are automatically
// indexed for efficient retrieval.
//
// IMPORTANT: Collections API requires a Management API Key with
// "AddFileToCollection" permission. Set via xai.management.api.key context var.
// ============================================================================

::ctx ::hot::ctx
is-ok-response ::hot::http/is-ok-response
HttpRequest ::hot::http/HttpRequest
HttpResponse ::hot::http/HttpResponse

// Management API has a different base URL
MANAGEMENT_BASE_URL "https://management-api.x.ai"

// ============================================================================
// Types
// ============================================================================

HttpError type {
    status: Int,
    headers: Map,
    body: Any
}

HttpResponse -> HttpError fn (response: HttpResponse): HttpError {
    HttpError({
        status: response.status,
        headers: response.headers,
        body: response.body
    })
}

// Collection entity
Collection type {
    id: Str,
    name: Str,
    description: Str?,
    created_at: Str?,
    updated_at: Str?,
    file_count: Int?,
    metadata_fields: Vec<MetadataField>?
}

// Metadata field definition
MetadataField type {
    name: Str,
    type: Str?,
    required: Bool?,
    unique: Bool?,
    inject_into_chunk: Bool?
}

// Collection list response
CollectionListResponse type {
    collections: Vec<Collection>
}

// Create collection request
CreateCollectionRequest type {
    name: Str,
    description: Str?,
    metadata_fields: Vec<MetadataField>?
}

// Update collection request
UpdateCollectionRequest type {
    name: Str?,
    description: Str?
}

// Document/File in a collection
Document type {
    id: Str,
    name: Str,
    collection_id: Str?,
    content_type: Str?,
    size: Int?,
    created_at: Str?,
    status: Str?,
    fields: Map?
}

// Search request
SearchRequest type {
    query: Str,
    collection_ids: Vec<Str>,
    max_results: Int?,
    retrieval_mode: RetrievalMode?
}

// Retrieval mode configuration
RetrievalMode type {
    type: Str  // "hybrid", "keyword", or "semantic"
}

// Search result
SearchResult type {
    content: Str?,
    file_id: Str?,
    file_name: Str?,
    score: Dec?,
    metadata: Map?
}

// Search response
SearchResponse type {
    results: Vec<SearchResult>
}

// ============================================================================
// API Helper (uses Management API Key)
// ============================================================================

management-request
meta {
    doc: "Make an HTTP request with Management API Key. Required for Collections API.",
    ctx: {"xai.management.api.key": {}}
}
fn
(method: Str, url: Str, additional-headers: Map, body: Any): HttpResponse {
    // Collections API requires Management API Key
    management-key ::ctx/get("xai.management.api.key")
    
    default-headers {
        Authorization: `Bearer ${management-key}`
    }

    // For GET/DELETE requests with no body, don't send Content-Type
    cond {
        or(eq(body, ""), is-null(body)) => {
            final-headers merge(default-headers, additional-headers)
            ::hot::http/request(HttpRequest({
                method: method,
                url: url,
                headers: final-headers
            }))
        }
        => {
            headers merge(default-headers, {Content-Type: "application/json"})
            final-headers merge(headers, additional-headers)
            ::hot::http/request(HttpRequest({
                method: method,
                url: url,
                headers: final-headers,
                body: to-json(untype(body))
            }))
        }
    }
},
(method: Str, url: Str): HttpResponse {
    management-request(method, url, {}, "")
}

// ============================================================================
// Collection Management
// ============================================================================

create
meta {
    doc: "Create a new collection.

**Example**
```hot
collection create({
    name: \"My Documents\",
    description: \"Research papers and notes\"
})

println(collection.id)  // \"collection_abc123...\"
```"
}
fn (request: CreateCollectionRequest): Collection | HttpError {
    response management-request("POST", `${MANAGEMENT_BASE_URL}/v1/collections`, {}, request)
    if(is-ok-response(response), Collection(response.body), err(HttpError(response)))
}

list
meta {
    doc: "List all collections.

**Example**
```hot
collections list()

for-each(collections.collections, (c) {
    println(`${c.name}: ${c.id}`)
})
```"
}
fn (): CollectionListResponse | HttpError {
    response management-request("GET", `${MANAGEMENT_BASE_URL}/v1/collections`)
    if(is-ok-response(response), CollectionListResponse(response.body), err(HttpError(response)))
}

get
meta {
    doc: "Get a collection by ID.

**Example**
```hot
collection get(\"collection_abc123\")
println(collection.name)
```"
}
fn (collection-id: Str): Collection | HttpError {
    response management-request("GET", `${MANAGEMENT_BASE_URL}/v1/collections/${collection-id}`)
    if(is-ok-response(response), Collection(response.body), err(HttpError(response)))
}

update
meta {
    doc: "Update a collection's name or description.

**Example**
```hot
collection update(\"collection_abc123\", {
    name: \"Updated Name\"
})
```"
}
fn (collection-id: Str, request: UpdateCollectionRequest): Collection | HttpError {
    response management-request("PATCH", `${MANAGEMENT_BASE_URL}/v1/collections/${collection-id}`, {}, request)
    if(is-ok-response(response), Collection(response.body), err(HttpError(response)))
}

delete
meta {
    doc: "Delete a collection.

**Example**
```hot
delete(\"collection_abc123\")
```"
}
fn (collection-id: Str): Map | HttpError {
    response management-request("DELETE", `${MANAGEMENT_BASE_URL}/v1/collections/${collection-id}`)
    if(is-ok-response(response), ok(response.body), err(HttpError(response)))
}

// ============================================================================
// Document Management
// ============================================================================

add-document
meta {
    doc: "Add an existing file to a collection. The file must first be uploaded via the Files API.

**Example**
```hot
// First upload file via ::xai::files/upload
// Then add to collection
doc add-document(\"collection_abc123\", \"file_xyz789\")
```"
}
fn (collection-id: Str, file-id: Str): Document | HttpError {
    add-document(collection-id, file-id, {})
},
(collection-id: Str, file-id: Str, fields: Map): Document | HttpError {
    body {
        file_id: file-id,
        fields: fields
    }
    response management-request("POST", `${MANAGEMENT_BASE_URL}/v1/collections/${collection-id}/documents`, {}, body)
    if(is-ok-response(response), Document(response.body), err(HttpError(response)))
}

remove-document
meta {
    doc: "Remove a document from a collection.

**Example**
```hot
remove-document(\"collection_abc123\", \"file_xyz789\")
```"
}
fn (collection-id: Str, file-id: Str): Map | HttpError {
    response management-request("DELETE", `${MANAGEMENT_BASE_URL}/v1/collections/${collection-id}/documents/${file-id}`)
    if(is-ok-response(response), ok(response.body), err(HttpError(response)))
}

// ============================================================================
// Search
// ============================================================================

search
meta {
    doc: "Search documents across one or more collections using semantic, keyword, or hybrid search.

**Search Modes:**
- `hybrid` (default) - Combines keyword and semantic for best results
- `keyword` - Exact matches of words, phrases, numbers
- `semantic` - Understands meaning and context

**Example**
```hot
results search({
    query: \"What were the key revenue drivers?\",
    collection_ids: [\"collection_abc123\"],
    max_results: 10,
    retrieval_mode: {type: \"hybrid\"}
})

for-each(results.results, (r) {
    println(`Score: ${r.score}, File: ${r.file_name}`)
    println(r.content)
})
```",
    ctx: {"xai.api.key": {}}
}
fn (request: SearchRequest): SearchResponse | HttpError {
    // Build the request body
    body {
        query: request.query,
        source: {
            collection_ids: request.collection_ids
        }
    }
    
    // Add optional fields
    body-with-max cond {
        is-null(request.max_results) => { body }
        => { merge(body, {max_results: request.max_results}) }
    }
    
    final-body cond {
        is-null(request.retrieval_mode) => { body-with-max }
        => { merge(body-with-max, {retrieval_mode: request.retrieval_mode}) }
    }
    
    // Search uses regular API key, not management key
    api-key ::ctx/get("xai.api.key")
    headers {
        Authorization: `Bearer ${api-key}`,
        Content-Type: "application/json"
    }
    
    response ::hot::http/request(HttpRequest({
        method: "POST",
        url: `${::xai/BASE_URL}/documents/search`,
        headers: headers,
        body: to-json(final-body)
    }))
    if(is-ok-response(response), SearchResponse(response.body), err(HttpError(response)))
}

// ============================================================================
// Convenience Functions
// ============================================================================

search-simple
meta {
    doc: "Simple search - query across collections and return results.

**Example**
```hot
results search-simple(\"revenue analysis\", [\"collection_abc123\"])
```"
}
fn (query: Str, collection-ids: Vec<Str>): SearchResponse | HttpError {
    search(SearchRequest({
        query: query,
        collection_ids: collection-ids
    }))
}

keyword-search
meta {
    doc: "Keyword search - exact word/phrase matching.

**Example**
```hot
results keyword-search(\"Q3 2024 revenue\", [\"collection_abc123\"])
```"
}
fn (query: Str, collection-ids: Vec<Str>): SearchResponse | HttpError {
    search(SearchRequest({
        query: query,
        collection_ids: collection-ids,
        retrieval_mode: RetrievalMode({type: "keyword"})
    }))
}

semantic-search
meta {
    doc: "Semantic search - finds conceptually related content.

**Example**
```hot
results semantic-search(\"financial performance\", [\"collection_abc123\"])
```"
}
fn (query: Str, collection-ids: Vec<Str>): SearchResponse | HttpError {
    search(SearchRequest({
        query: query,
        collection_ids: collection-ids,
        retrieval_mode: RetrievalMode({type: "semantic"})
    }))
}

// ============================================================================
// Retrieval Mode Constants
// ============================================================================

MODE_HYBRID RetrievalMode({type: "hybrid"})
MODE_KEYWORD RetrievalMode({type: "keyword"})
MODE_SEMANTIC RetrievalMode({type: "semantic"})
