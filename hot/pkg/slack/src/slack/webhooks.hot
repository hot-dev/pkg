::slack::webhooks ns

// Namespace aliases
::ctx  ::hot::ctx
::hmac ::hot::hmac
::time ::hot::time

// ============================================================================
// Slack Webhook Signature Verification
// ============================================================================
// Slack signs every Events API callback with HMAC-SHA256 using your app's
// signing secret. The signature is sent in the X-Slack-Signature header.
//
// See: https://api.slack.com/authentication/verifying-requests-from-slack

verify-request
meta {
  ctx: {"slack.signing.secret": {required: true}},
  doc: "Verify a Slack webhook request signature. Returns true if the request is authentic. Uses the slack.signing.secret context variable by default, or accepts an explicit signing secret as a second argument for multi-app scenarios."
}
fn
// 1-arity: read signing secret from ctx (default)
(request: HttpRequest): Bool {
  verify-request(request, or(::ctx/get("slack.signing.secret"), ""))
},
// 2-arity: explicit signing secret (override for multi-app)
(request: HttpRequest, signing-secret: Str): Bool {
  // Extract the timestamp and signature from headers
  timestamp get(request.headers, "x-slack-request-timestamp", "")
  signature get(request.headers, "x-slack-signature", "")

  // Reject if secret or headers are missing
  cond {
    is-empty(signing-secret) => { false }
    is-empty(timestamp) => { false }
    is-empty(signature) => { false }
    => {
      // Build the base string: v0:{timestamp}:{body_raw}
      base-string `v0:${timestamp}:${request.body-raw}`

      // Compute the expected signature
      expected `v0=${::hmac/hmac-sha256(signing-secret, base-string)}`

      // Constant-time comparison to prevent timing attacks
      secure-compare(expected, signature)
    }
  }
}
