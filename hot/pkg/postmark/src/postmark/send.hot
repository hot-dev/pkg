::postmark::send ns

api-request ::postmark::api/request
HttpError ::postmark::api/HttpError
is-ok-response ::hot::http/is-ok-response

// List of email attachments. Each attachment has Name, Content (base64), and ContentType.
AttachmentCollection type Vec<Map>

// List of custom email headers. Each header has Name and Value.
HeaderCollection type Vec<Map>

SendEmailRequest type {
    From: Str?,
    To: Str?,
    Cc: Str?,
    Bcc: Str?,
    Subject: Str?,
    Tag: Str?,
    HtmlBody: Str?,
    TextBody: Str?,
    ReplyTo: Str?,
    TrackOpens: Bool?,
    TrackLinks: "None" | "HtmlAndText" | "HtmlOnly" | "TextOnly"?,
    Headers: HeaderCollection?,
    Attachments: AttachmentCollection?
}

SendEmailResponse type {
    To: Str?,
    SubmittedAt: Str?,
    MessageID: Str?,
    ErrorCode: Int?,
    Message: Str?
}


send-single-email
meta {
    doc: """
    Send a single email via the Postmark API.

    **Example**

    ```hot
    response ::postmark::send/send-single-email(::postmark::send/SendEmailRequest({
        From: "sender@example.com",
        To: "recipient@example.com",
        Subject: "Welcome!",
        TextBody: "Plain text body.",
        HtmlBody: "<html><body><p>HTML body</p></body></html>"
    }))
    response.MessageID // => "unique-message-id"
    response.ErrorCode // => 0
    ```
    """
}
fn (request: SendEmailRequest): SendEmailResponse {
  response api-request("POST", `${::postmark/BASE_URL}/email`, {}, request)
  if(is-ok-response(response), SendEmailResponse(response.body), err(HttpError(response)))
}

// Convenience alias
email send-single-email

// Batch email request: array of individual email objects
SendEmailBatchRequest type Vec<Map>

// Batch email response: array of results for each email in the batch
SendEmailBatchResponse type Vec<Map>


send-batch-emails
meta {doc: """Send a batch of emails in a single API call."""}
fn (request: SendEmailBatchRequest): SendEmailBatchResponse {
  response api-request("POST", `${::postmark/BASE_URL}/email/batch`, {}, request)
  if(is-ok-response(response), SendEmailBatchResponse(response.body), err(HttpError(response)))
}

EmailWithTemplateRequest type {
    TemplateId: Int,
    TemplateAlias: Str,
    TemplateModel: Map,
    InlineCss: Bool?,
    From: Str,
    To: Str,
    Cc: Str?,
    Bcc: Str?,
    Tag: Str?,
    ReplyTo: Str?,
    Headers: HeaderCollection?,
    TrackOpens: Bool?,
    TrackLinks: "None" | "HtmlAndText" | "HtmlOnly" | "TextOnly"?,
    Attachments: AttachmentCollection?
}

SendEmailWithTemplateRequest type {
    TemplateId: Int,
    TemplateAlias: Str,
    TemplateModel: Map,
    InlineCss: Bool?,
    From: Str,
    To: Str,
    Cc: Str?,
    Bcc: Str?,
    Tag: Str?,
    ReplyTo: Str?,
    Headers: HeaderCollection?,
    TrackOpens: Bool?,
    TrackLinks: "None" | "HtmlAndText" | "HtmlOnly" | "TextOnly"?,
    Attachments: AttachmentCollection?
}

SendEmailWithTemplateResponse type {
    To: Str?,
    SubmittedAt: Str?,
    MessageID: Str?,
    ErrorCode: Int?,
    Message: Str?
}


send-email-using-template
meta {
    doc: """Send an email using a pre-defined Postmark template, identified by TemplateId or TemplateAlias."""
}
fn (request: SendEmailWithTemplateRequest): SendEmailWithTemplateResponse {
  response api-request("POST", `${::postmark/BASE_URL}/email/withTemplate`, {}, request)
  if(is-ok-response(response), SendEmailWithTemplateResponse(response.body), err(HttpError(response)))
}

SendEmailTemplatedBatchRequest type {
    Messages: Vec<EmailWithTemplateRequest>?
}

SendEmailBatchWithTemplatesRequest type {
    Messages: Vec<EmailWithTemplateRequest>?
}

// Batch template email response: array of results for each templated email
SendEmailBatchWithTemplatesResponse type Vec<Map>


send-batch-email-using-templates
meta {doc: """Send a batch of emails using templates in a single API call."""}
fn (request: SendEmailBatchWithTemplatesRequest): SendEmailBatchWithTemplatesResponse {
  response api-request("POST", `${::postmark/BASE_URL}/email/batchWithTemplates`, {}, request)
  if(is-ok-response(response), SendEmailBatchWithTemplatesResponse(response.body), err(HttpError(response)))
}
