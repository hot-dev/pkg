::mcp::client ns
meta {doc: "MCP client session management. Handles the initialize handshake and provides internal request helpers used by tools, resources, and prompts modules."}

::rpc ::json-rpc::client
::types ::mcp::types

StreamingHttpResponse ::hot::http/StreamingHttpResponse

PROTOCOL_VERSION "2025-11-25"

// ============================================================================
// Session Initialization
// ============================================================================

// Initialize an MCP session with a remote server.
// Performs the full handshake: initialize request + initialized notification.
initialize
meta {doc: "Connect to an MCP server and perform the initialize handshake.

Returns a Session that must be passed to all subsequent operations
(tools/list, tools/call, resources/read, etc.).

**Example**

```hot
::mcp ::mcp::client

session ::mcp/initialize(
  \"https://my-server.example.com/mcp\",
  {name: \"my-app\", version: \"1.0.0\"},
  null
)
```"}
fn (url: Str, client-info: ::types/ClientInfo, capabilities: ::types/ClientCapabilities?): ::types/Session {
  // Step 1: Send initialize request
  req ::rpc/request("initialize", {
    protocolVersion: PROTOCOL_VERSION,
    capabilities: or(untype(capabilities), {}),
    clientInfo: untype(client-info)
  })

  response ::rpc/send(url, {}, req)
  result response.result

  server-info ::types/ServerInfo(result.serverInfo)
  server-caps ::types/ServerCapabilities(or(result.capabilities, {}))
  session-id get(result, "sessionId", null)

  // Build session headers for all subsequent requests
  base-headers {"Mcp-Protocol-Version": PROTOCOL_VERSION}
  session-headers if(is-some(session-id),
    assoc(base-headers, "Mcp-Session-Id", session-id),
    base-headers)

  // Step 2: Send initialized notification
  ::rpc/notify(url, session-headers, ::rpc/notification("notifications/initialized", null))

  ::types/Session({
    url: url,
    session-id: session-id,
    protocol-version: or(result.protocolVersion, PROTOCOL_VERSION),
    server-info: server-info,
    server-capabilities: server-caps,
    headers: session-headers
  })
}

// ============================================================================
// Internal Request Helpers
// ============================================================================

// Send a request within an active session and return the result map.
session-request
meta {doc: "Send a JSON-RPC request within an active MCP session. Returns the result map from the response."}
fn (session: ::types/Session, method: Str, params: Map?): Map {
  req ::rpc/request(method, params)
  response ::rpc/send(session.url, session.headers, req)
  or(response.result, {})
}

// Send a streaming request within an active session.
// Returns a StreamingHttpResponse whose .body is an SSE-parsed iterator.
session-request-stream
meta {doc: "Send a streaming JSON-RPC request within an active MCP session. Returns a StreamingHttpResponse with an SSE iterator body."}
fn (session: ::types/Session, method: Str, params: Map?): StreamingHttpResponse {
  req ::rpc/request(method, params)
  ::rpc/send-stream(session.url, session.headers, req)
}

// ============================================================================
// Utilities
// ============================================================================

// Ping the server to check connectivity.
ping
meta {doc: "Ping the MCP server to verify the session is alive.

**Example**

```hot
::mcp ::mcp::client
::mcp/ping(session) // true
```"}
fn (session: ::types/Session): Bool {
  session-request(session, "ping", null)
  true
}
